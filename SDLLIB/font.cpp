#include <algorithm>

#include "font.h"

int FontXSpacing;
int FontYSpacing;
char FontWidth ;
char FontHeight;
char *FontWidthBlockPtr;

void const *FontPtr;

// most of this table is because Buffer_Print doesn't do a shift...
uint8_t ColorXlat[]
{
    0x00,0x01,0x02,0x03,0x04,0x05,0x06,0x07,
    0x08,0x09,0x0A,0x0B,0x0C,0x0D,0x0E,0x0F,

    0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,

    0x02,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,

    0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,

    0x04,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,

    0x05,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,

    0x06,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,

    0x07,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,

    0x08,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,

    0x09,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,

    0x0A,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,

    0x0B,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,

    0x0C,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,

    0x0D,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,

    0x0E,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,

    0x0F
};


void *Set_Font(void const *fontptr)
{
    void *oldfont;
    char const *blockptr;

    oldfont = (void *) FontPtr;

    if (fontptr) {
        FontPtr = fontptr;

        /*
        **	Inform the system about the new font.
        */

        FontWidthBlockPtr = (char*)fontptr + *(unsigned short *)((char*)fontptr + FONTWIDTHBLOCK);
        blockptr  = (char*)fontptr + *(unsigned short *)((char*)fontptr + FONTINFOBLOCK);
        FontHeight = *(blockptr + FONTINFOMAXHEIGHT);
        FontWidth  = *(blockptr + FONTINFOMAXWIDTH);
    }

    return oldfont;
}

int Char_Pixel_Width(char chr)
{
    return (unsigned char)*(FontWidthBlockPtr + (unsigned char)chr) + FontXSpacing;
}

unsigned int String_Pixel_Width(char const *string)
{
	int width;				// Working accumulator of string width.
	int largest = 0;		// Largest recorded width of the string.

	if(!string)
        return 0;

	width = 0;
	while(*string) {
		if(*string == '\r') {
			string++;
			largest = std::max(largest, width);
			width = 0;
		} else {
			width += Char_Pixel_Width(*string++);	// add each char's width
		}
	}
	largest = std::max(largest, width);
	return largest;
}

void Set_Font_Palette_Range(void const *palette, int start_idx, int end_idx)
{
    auto palette8 = (uint8_t *)palette;

    start_idx &= 0xF;
    end_idx &= 0xF;

    if(end_idx < start_idx)
        return;

    int num_cols = (end_idx - start_idx) + 1;

    auto lo = ColorXlat + start_idx;
    auto hi = ColorXlat + (start_idx * 16);

    do {
        int col = *palette8++;
        *lo++ = col;
        *hi = col;
        hi += 16;
    }
    while(--num_cols);
}

extern "C" void *Get_Font_Palette_Ptr()
{
    return ColorXlat;
}